+ 检测对象类型 
``` Javascript
    var toString = Object.prototype.toString;

    toString.call(new String) //[object String]
    
    toString.call(new Date); // [object Date]
```

出处：src\shared\util.js

+ 判断是否是对象  

```javascript
export function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}
```
出处：test\weex\helpers\index.js

+ Object.defineProperty

Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有熟悉，并返回此对象

出处：src\core\instance\state.js

proxy代理，将data上的数据代理到vm上
``` Javascript
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

+ instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

+ def

+ Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符   https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor



+ virtual dom
virtual dom主要包含几个步骤
1. 用JavaScript对象结构表示DOM树，在通过这个结构去构造应该真正的DOM树，插入到HTML文档中
2. 当状态发生变更时，重新构造一颗新的DOM树，对比与之前树的差异并记录   
3. 将2中记录的差异更新到1中所构建的真正的DOM树，完成视图的更新

如何对比差异
diff算法：算法详解 https://segmentfault.com/a/1190000021896771  动态规划  https://leetcode-cn.com/problems/edit-distance/ 72编辑距离问题类似


+ AST（abstract syntax tree）抽象语法树

https://astexplorer.net/ 可以查看生成的AST

+ 父子组件间通信
单向数据流
所有的props都使得父子prop之间形成了应该单向下行绑定：父级prop的更新会下流到子组件中，反过来则不需。这样会防止子组件意外改变父组件的状态。
当父组件发生变更时，子组件中酥油的prop都会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告
常见的两种需要改变props的情况
1.这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：
```js
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```
2.这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：
```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```
注意： JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。

父组件向子组件传值：
通过prop
v-model
深层次的可以使用provide和inject
父组件通过$ref访问子组件的属性和方法
$emit子组件向父组件提供方法

+ vue-router
1. vue-router流程
![router](./images/router.png)
2. 懒加载写法
```js
//ES6的import()
import Vue from 'vue';
import Router from 'vue-router';
import HelloWorld=()=>import('@/components/HelloWorld');
Vue.use('Router')
export default new Router({
	routes:[{
	{path:'./',
	name:'HelloWorld',
	component:HelloWorld
	}
	}]
})
//vue异步组件
import Vue from 'vue';
import Router from 'vue-router';
const HelloWorld=resolve=>{require(["@/components/HelloWorld"],resolve}
Vue.use(Router);
export default new Router({
routes:[
	{path:'./',
	name:'HelloWorld',
	component:HelloWorld
	}
]
})
//webpack的require.ensure()
import Vue from 'vue';
import Router from 'vue-router';
const HelloWorld=resolve=>{
		require.ensure(['@/components/HelloWorld'],()=>{
			resolve(require('@/components/HelloWorld'))
		})
	}
Vue.use('Router')
export default new Router({
	routes:[{
	{path:'./',
	name:'HelloWorld',
	component:HelloWorld
	}
	}]
})
```

+ keep-alive
keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
https://www.jianshu.com/p/9523bb439950
https://blog.csdn.net/dongcehao/article/details/107050723 LRU缓存机制
leetcode  https://leetcode-cn.com/problems/lru-cache/submissions/